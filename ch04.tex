\chapter{Робота з рядками. Регулярні вирази}
\section*{Мета роботи}
Ознайомитись із засобами роботи з рядковими змінними та константами. Ознайомитись із застосуванням регулярних виразів у мові РНР та SQL-запитах.
\nopagebreak[4]
\section{Рядки. Функції роботи з рядками}
\nopagebreak[4]
\index{PHP!змінні!рядки}
\textbf{Рядки є послідовностями символів}. У PHP символ відповідає байту, тобто існує точно 256 можливих різних символів. Рядки можуть бути дуже великими. У PHP не існує практичного обмеження на розмір рядків, тому взагалі немає причин турбуватися про їх довжині. Строкові значення можуть використовуватися буквально або присвоюватися змінним.

У PHP рядковий літерал можна задати трьома способами.
\begin{itemize}
\item рядки в одиночних лапках
\item рядки в подвійних лапках
\item рядки в синтаксисі heredoc 
\end{itemize}

\subsection*{Рядки в одиночних лапках}
Одиночні лапки надають найпростіший метод для роботи з рядками. При використанні цього методу рядки укладаються в одиночні лапки <<''>>. Якщо одиночні лапки потрібні як частина рядка, вони повинні бути екрановані символом зворотної косої межі <<\\>>. Хоча одиночні лапки надають простий спосіб роботи з рядками, одиночні лапки не підтримують застосування інтерполяції.
\subsection*{Рядки в подвійних лапках}
Рядки PHP можна виводити також за допомогою подвійних лапок <<"">>. Якщо рядки PHP поміщаються в подвійні лапки, то можна застосовувати інтерполяцію. Для рядків у подвійних лапках PHP підтримує також більшість екранованих символів. Ці символи представлені в таблиці~\ref{doub-lap:table} нижче.

\begin{center}
\begin{longtable}[t]{|l|p{20em}|}
\caption{Екрановані символи у подвійних лапках} \label{doub-lap:table}\\
\hline
Символ & Опис \\
\hline
\verb'\N' & перенесення рядка \\
\verb'\R' & повернення каретки \\
\verb'\T' & горизонтальна табуляція \\
\verb'\\' & зворотна коса риска \\
\verb'\$' & знак долара \\
\verb'\"' & подвійні лапки \\
\hline
\end{longtable}
\end{center}

\subsection*{Рядки в синтаксисі heredoc}
\textbf{Heredoc}-синтаксис~--- спосіб визначення строкових змінних у вихідному коді програм.

При визначенні строкових змінних їх вміст, зазвичай, полягає в одинарні або подвійні лапки, у зв'язку з чим символи лапок, які повинні бути частиною даних, доводиться екранувати за допомогою escape-послідовностей. Heredoc-синтаксис дозволяє визначити рядок, не укладаючи її в лапки, у зв'язку з чим необхідність екранування цих символів відпадає.

Приклад використання такого синтаксису наведено нижче:
\begin{verbatim}
$S = << EOL; 
Лапки бувають 'одинарними' і "подвійними". 
EOL
\end{verbatim} 
\subsection*{Функції роботи з рядками}
\index{PHP!змінні!рядки!функції}
У базовому наборі РНР існує величезна кількість функцій для обробки рядків. Як правило іх достатньо для написання програм, іноді необхідно комбінувати ці функції між собою для отримання необхідного результату. Повний перелік функцій дан у таблиці~\ref{str-func:table} додатків.

\pagebreak[3]
\section{Рядки, що включають HTML-код}
\nopagebreak[4]

\index{PHP!змінні!HTML-рядки}Досить часто ми працюємо з рядками, що містять html-теги. Якщо відобразити такий рядок в браузері за допомогою звичайних функцій відображення даних \verb'echo()' або \verb'print()', то ми не побачимо самих html-тегів, а отримаємо відформатовану у відповідності з цими тегами сторінку. Браузер обробляє всі html-теги у відповідності зі стандартом мови HTML. Іноді нам потрібно бачити безпосередньо рядок, без обробки його браузером. Щоб цього досягти, потрібно перед тим, як виводити, застосувати до рядка функцію \verb'htmlspecialchars()'.

\pagebreak[3]
\section{Регулярні вирази}
\nopagebreak[4]
\index{PHP!регулярні вирази}
\textbf{Регулярний вираз} (regular expression)~--- це технологія, яка дозволяє задати шаблон і здійснити пошук даних, відповідних цьому шаблону, в заданому тексті, представленому у вигляді рядка. Одне з поширених застосувань регулярних виразів~--- це перевірка рядка на відповідність будь-яким правилам.

Приклад регулярного виразу:
\begin{verbatim}
/^\w+([\.\w]+)*\w@\w((\.\w)*\w+)*\.\w{2,3}$/
\end{verbatim}
Основна перевага РВ полягає в тому, що вони дозволяють організувати більш гнучкий пошук, тобто знайти те, про що немає точного знання, але є приблизне уявлення. Наприклад, потрібно знайти всі семизначні номери телефонів, що зустрічаються в тексті. Ми не шукаємо якийсь заздалегідь відомий нам номер телефону, ми знаємо тільки, що шуканий номер складається з семи цифр. Для цього можна скористатися наступним РВ:

\begin{verbatim}
/\d{3}-\d{2}-\d{2}/m
\end{verbatim}

Одним з основних метасимволів є зворотний слеш <<\\>>. Він змінює тип символу, наступного за ним, на протилежний, тобто якщо це був звичайний символ, то він МОЖЕ перетворитися в метасимвол, якщо це був метасимвол, то він втрачає своє спеціальне значення і стає звичайним символом (це потрібно для того, щоб вставляти в текст спеціальні символи як звичайні). Наприклад, символ <<d>> в звичайному режимі не має ніяких спеціальних значень, але <<\\d>> є метасимволом, що означає "будь-яка цифра". Символ <<.>> в звичайному режимі означає будь одиничний символ, а <<\\.>> означає просто крапку.

Результати використання зворотнього слеша надано у таблиці\index{PHP!регулярні вирази!слеш-комбінації}:
\begin{center}
\begin{longtable}[t]{|l|p{20em}|}
\kill
\caption{\space Використання зворотнього слеша у регулярних виразах} \label{chr-meta:table}\\
\hline

Символ & Значення \\
\hline \endfirsthead
\caption*{\space Продовження} \\
\hline
Символ & Значення \\
\hline \endhead
\hline \endfoot
\verb'\n' & cимвол перекладу рядка \\

\verb'\e' & символ escape \\

\verb'\t' & cимвол табуляції \\

\verb'\Xhh' & символ в шістнадцятковому коді, наприклад \verb'\x41' є буква A і т.д. \\

\verb'\d' & будь-яка десяткова цифра (0-9) \\

\verb'\D' & будь-який символ, який не є десятковим цифрою \\

\verb'\s' & будь-який порожній символ (пробіл або табуляція) \\

\verb'\S' & будь-який символ, який не є порожнім \\

\verb'\w' & символ, використовуваний для написання Perl-слів (це літери, цифри та символ підкреслення), так званий "словниковий символ" \\

\verb'\W' & знайдене символ (всі символи, крім обумовлених \verb'\w') \\ 
\hline
\end{longtable}
\end{center}

Приклад використання наведених вище метасимволів:

\begin{verbatim}
/\d\d\d plus \d is \w\w\w/
\end{verbatim}

Цей регулярний вираз означає: тризначне число, за яким слідує підрядок \verb'plus', будь-яка цифра, потім \verb'is' і слово з трьох словникових символів. Зокрема, даним РВ задовольняють рядки: <<\verb'123 plus 3 is sum'>>, <<\verb'213 plus 4 is 217'>>.

\pagebreak[3]
\section{Функції PHP для роботи з регулярними виразами}
\nopagebreak[4]
\index{PHP!регулярні вирази!функції}
Основні функції для роботи з Perl-сумісними регулярними виразами: \verb'preg_match(pattern, string, [result, flags])' і \verb'preg_match_all(pattern, string, result, [flags])', де:

\verb'pattern'~--- шаблон регулярного виразу;

\verb'string'~--- рядок, в якій проводиться пошук;

\verb'result'~--- містить масив результатів (нульовий елемент масиву містить відповідність всьому шаблоном, перший~--- першому <<захопленому>> підшаблону і т.д.);

\verb'flags'~--- необов'язковий параметр, що визначає те, як впорядковані результати пошуку.

Ці функції здійснюють пошук за шаблоном і повертають інформацію про те, скільки разів відбувся збіг. Для \verb'preg_match()' це O (немає збігів) або 1, оскільки пошук припиняється, як тільки знайдено перший збіг. Функція \verb'preg_match_all()' робить пошук до кінця рядка і тому знаходить всі збіги. Всі точні збіги містяться в першому елементі масиву result у кожної з цих функцій (для \verb'preg_match_all()' цей елемент~--- теж масив). 
Аналогом \verb'preg_match' є булева функція POSIX-розширення \verb'ereg(string pattern, string string [, array regs])'

Функція \verb'ereg()' повертає \verb'TRUE', якщо збіг знайдено, і \verb'FALSE'~--- у противному випадку.

Наведені далі приклади можна тестувати на перерахованих функціях. Наприклад, так:



\begin{lstlisting}[caption=Приклад роботи з регулярними виразами]
<?
//Рядок, в якому потрібно щось знайти
$str = "Мій телефонний номер:".
"33-22-44. Номер мого редактора:".
"222-44-55 та 323-22-33";
//Шаблон, по якому шукати.
//Задає пошук семизначних номерів.
$pattern = "/\d{3}-\d{2}-\d{2}/m";
//Функція, що здійснює пошук
$num_match = preg_match_all($pattern, $str, $result);
//Вивід результатів пошуку
for ($i = 0; $i <$num_match; $i++) 
echo "Збіг $i:".$result[0][$i]."<br>";
?>
\end{lstlisting}






\pagebreak[3]
\section{Регулярні вирази в SQL-запитах}
\nopagebreak[4]
\index{MySQL!SQL!регулярні вирази}
Більшість сучасних СУБД також підтримують регулярні вирази. Це буває корисним коли необхідно отримати або змінити дані в базі, що відповідають певному шаблону.

В MySQL використовується розширена версія  реалізації регулярних виразів, яка орієнтована на відповідність POSIX 1003.2. Це розширена версія, в якій підтримуються операції порівняння із зразком, використовуючи оператор \verb'REGEXP' в операторах SQL.

Наприклад запит \verb|SELECT * FROM tab WHERE text REGEXP "B[an]*s"| поверне рядки <<Bananas>> та <<Baaaaas>>, якщо такі є в таблиці бази даних.

Перелік метасимволів, що підтримує MySQL, дано в таблиці~\ref{chr-rxp:table} додатків.

Альтернативою \verb'REGEXP' може виступати оператор \verb'RLIKE'. Оператор \verb'RLIKE' можна використовувати з запереченням \verb'NOT RLIKE'~--- в цьому випадку результатом його роботи буде вибірка рядків не відповідають заданим параметрам.
\pagebreak[3]
\section{Індивідуальне завдання}

\nopagebreak[4]
\subsection*{Завдання до лабораторної роботи}
\nopagebreak[4]
\begin{enumerate}
\item Вивчити теоретичний матеріал
\item Відповісти на контрольні запитання
\item Скласти алгоритм (блок-схему) програми
\item Виконати практичне завдання
\item Скласти звіт
\item Захистити роботу
\end{enumerate}

\subsection*{Контрольні запитання}
\nopagebreak[4]
\begin{enumerate}
\item Що таке рядки?
\item Яким чином можна задати рядковий літерал?
\item Яка особливість рядків у подвійних лапках?
\item Яка особливість синтаксису \verb'Heredoc'? 
\item Яким чином вивести HTML-код на веб-сторінці?
\item Що таке регулярні вирази?
\item Яка особливість метасимволу <<\verb'\'>>?
\item Для чого використвуються регулярні вирази?
\item Які функції для роботи з регулярними виразами ви знаєте?
\item Яким чином можна використовувати регулярні вирази в SQL-запитах?
\end{enumerate}

\subsection*{Практичні завдання}
\nopagebreak[4]


\begin{enumerate}
\item[]Створити HTML-форму з трьома однорядковими полями вводу та обробити інформацію у сценарії наступним чином:
\item у рядку \No1 знайти всі місця входження рядків \No\No2 та 3
\item до рядка \No1 додати рядок \No2 та знайти входження рядка \No3 в отриманому
\item у рядку \No1 знайти входження об'єднаних рядків \No2 та \No3
\item у рядку \No1 замінити перше попадання рядку \No2 на рядок \No3
\item у рядку \No1 замінити останнє попадання рядку \No2 на рядок \No3
\item у рядку \No1 замінити всі попадання рядку \No2 на рядок \No3
\item видалити пробіли на початку та кінцях усіх рядків
\item у рядку \No1 видалити HTML-теги, рядок \No2 вивести у браузері з  HTML-тегами
\item об'єднати усі рядки, якщо довжина рядків \No2 та \No3 співпадає
\item об'єднати усі рядки, якщо 5 перших символів рядків \No2 та \No3 співпадають
\item у рядку \No1 знайти місця входження перших символів рядків \No\No2 та 3
\item перетворити половину рядка \No1 у верхній регістр, рядки \No\No2 та 3 перетворити у нижній
\item перемішати символи у рядку \No1, якщо довжина рядків \No2 та \No3 не співпадає
\item підрахувати кількість входжень рядків \No\No2 та 3 у рядку \No1 
\item першу букву кожного слова у рядку \No1 перевести у верхній регістр, якщо довжина рядка \No2 < довжини рядка \No3, інакше об'єднати усі рядки
\item об'єднати усі рядки та перевернути отриманий результат
\item[]Результати роботи з рядками вивести на сторінку веб-браузера 
\item[]Створити HTML-форму з однорядковим полем вводу та багаторядковим текстовим полем та створити регулярний вираз для пошуку в тексті:
\item номера телефону виду (044)123-45-67
\item номера телефону виду (0552)12-34-56
\item IP-адрес виду 192.168.1.ххх
\item MAC-адрес виду 12:34:56:78:90:AB
\item слів \verb'ololo' та \verb'olalo'
\item слів \verb'bus', \verb'trolleybus' та \verb'boss'
\item слів \verb'mix', \verb'm1x' та \verb'mixer'
\item HTTP-посилань \verb'http:\\domen1.ua', \verb'http:\\domen2.ua' та \verb'http:\\domen3.uk'
\item HTTP-посилань \verb'http:\\domen1.ks.ua', \verb'http:\\domen2.kks.ua'
\item[]Результати роботи з регулярними виразами вивести на сторінку веб-браузера 

\end{enumerate}


