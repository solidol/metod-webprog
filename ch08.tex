\chapter{ООП. Робота з XML}
\index{PHP!ООП}
Хоча РНР володіє загальними об'єктно-орієнтованими можливостями, він не є повноцінною ОО-мовою (наприклад, такою, як C++ або Java). Зокрема, в РНР не підтримуються наступні об'єктно-орієнтовані можливості:
\begin{itemize}
\item множинне спадкування;
\item автоматичний виклик конструкторів (якщо ви хочете, щоб при конструюванні об'єкта похідного класу викликався конструктор базового класу, вам доведеться викликати його явно);
\item абстрактні класи;
\item перевантаження методів;
\item перевантаження операторів (це пов'язано з тим, що РНР є мовою з вільною типізацією);
закритий і відкритий доступ, віртуальні функції;
\item деструктори.
\end{itemize}

Але і без усього перерахованого ви все одно зможете отримати користь з об'єктно-орієнтованих можливостей, підтримуваних РНР. Реалізація ООП в РНР надає колосальну допомогу в модульному оформленні функціональності вашої програми.
\section{Класи та об'єкти. Методи}
\index{PHP!ООП!класи}
\index{PHP!ООП!об'єкти}
Класи утворюють синтаксичну базу об'єктно-орієнтованого програмування. Їх можна розглядати як свого роду <<контейнери>> для логічно пов'язаних даних і функцій (методів). Клас являє собою шаблон, по якому створюються конкретні екземпляри, використовуються в програмі. Екземпляри класів називаються об'єктами.

\subsection{Оголошення класу}
Клас можна розглядати як тип даних, а об'єкт~--- як змінну. Програма може одночасно працювати з декількома об'єктами одного класу як і з декількома змінними. Загальний формат класів РНР приведений в наступному лістингу.

\begin{lstlisting}[caption=Синтаксис оголошення класів]
class Class_name {
var $attribute_1;
//...
var $attribute_N;
function function1() {
//...
}
//...
function functionN() {
//...
}
} // end Class_name 
\end{lstlisting}

Оголошення класу має починатися з ключового слова \verb|class| (подібно до того, як оголошення функції починається з ключового слова \verb|function|). Кожному оголошенню атрибуту, що міститься в класі, має передувати ключове слово \verb|var|. Атрибути можуть відноситися до будь-якого типу даних, підтримуваних в РНР. Після оголошень атрибутів слідують оголошення методів, дуже схожі на типові оголошення функцій.

Методи часто використовуються для роботи з атрибутами класів. При посиланнях на атрибути всередині методів використовується спеціальна змінна \verb|$this|. Синтаксис методів продемонстрований в наступному прикладі:

\begin{lstlisting}[caption=Приклад створення методів]
<?
class Webpage {
var $bgcolor;
function setBgColor($color) {
$this->bgcolor = $color;
}
function getBgColor() {
return $this->bgcolor;
}
}
?> 
\end{lstlisting}

Змінна \verb|$this| посилається на екземпляр об'єкта, для якого викликається метод. Оскільки в будь-якому класі може існувати декілька екземплярів об'єктів, уточнення \verb|$this| необхідно для посилань на атрибути, що належать поточному об'єкту. При використанні цього синтаксису зверніть увагу на дві обставини:

\begin{enumerate}
\item атрибут, на який ви посилаєтеся в методі, не потрібно передавати у вигляді параметра функції;
\item знак долара (\$) ставиться перед змінною \verb|$this|, але не перед ім'ям атрибута (як у звичайної змінної).
\end{enumerate}

\subsection{Створення об'єкта}


\section{Наслідування}
\index{PHP!ООП!наслідування}

\section{Конструктори та деструктори}
\index{PHP!ООП!коснструктори}
\index{PHP!ООП!Деструктори}

Досить часто при створенні об'єкта потрібно задати значення деяких атрибутів. На щастя, розробники технології ООП врахували цю обставину і реалізували його в концепції конструкторів. Конструктор являє собою метод, який задає значення деяких атрибутів (а також може викликати інші методи). Конструктори викликаються автоматично при створенні нових об'єктів. Щоб це стало можливим, ім'я методу-конструктора повинне збігатися з ім'ям класу, в якому він міститься. Приклад конструктора приведений в лістингу 2.

\section{Оператори <<::>> та <<parent>>}
\index{PHP!ООП!<<::>>}
\index{PHP!ООП!<<parent>>}


\section{Об'єктна модель XML-документа}
\index{PHP!XML}
\section{Розширення SAX та DOM для роботы з XML}
\index{PHP!XML!SAX}
\index{PHP!XML!DOM}

\pagebreak[3]
\section{Індивідуальне завдання}

\nopagebreak[4]
\subsection*{Завдання до лабораторної роботи}
\nopagebreak[4]
\begin{enumerate}
\item Вивчити теоретичний матеріал
\item Відповісти на контрольні запитання
\item Скласти алгоритм (блок-схему) програми
\item Виконати практичне завдання
\item Скласти звіт
\item Захистити роботу
\end{enumerate}

\subsection*{Контрольні запитання}
\nopagebreak[4]
\begin{enumerate}
\item Що таке рядки?
\item Яким чином можна задати рядковий літерал?
\item Яка особливість рядків у подвійних лапках?
\item Яка особливість синтаксису \verb'Heredoc'? 
\item Яким чином вивести HTML-код на веб-сторінці?
\item Що таке регулярні вирази?
\item Яка особливість метасимволу <<\verb'\'>>?
\item Для чого використвуються регулярні вирази?
\item Які функції для роботи з регулярними виразами ви знаєте?
\item Яким чином можна використовувати регулярні вирази в SQL-запитах?
\end{enumerate}

\subsection*{Практичні завдання}
\nopagebreak[4]


\begin{enumerate}
\item[]Написати HTML-сторінку з формою, що складається з:
\item однорядкового поля вводу, поля вводу пароля та кнопки відправлення форми.
\item 

\end{enumerate}

