\chapter{Взаємодія PHP та web-сервера. Синтаксис PHP}
\nopagebreak[4]
\section*{Мета роботи}
Ознайомитись зі змінними оточення веб-серверу та суперглобальними масивами РНР. Ознайомитись з конструкціями розгалуження, циклів, включення файлів.
\section{Змінні оточення web-сервера Apache, суперглобальні масиви PHP}
\nopagebreak[4]

\subsection*{Змінні оточення web-сервера Apache}
\index{Web-сервери!Apache!змінні оточення}
\textbf{Змінні оточення}~--- дуже важливий механізм взаємодії веб-сервера з предобработчікамі запитів. При отриманні HTTP-запиту веб-сервер формує змінні оточення, заносячи в них різну інформацію: IP-адреса клієнта, запитуваний документ, параметри запиту і т.п. При передачі управління якомусь предобработчіку останній має доступ до змінних оточення веб-сервера, отже, йому доступна вище перерахована інформація.

Безпосередньо перед запуском сценарію сервер передає йому якісь змінні оточення з інформацією. Змінні оточення в мові PHP можна використовувати як звичайнісінькі змінні. Змінні оточення діляться на чотири великі групи:
\begin{enumerate}
\item Формовані сервером змінні;
\item Спеціальні змінні сервера Apache;
\item Змінні HTTP-полів запиту;
\item Змінні SSL-з'єднання (захищеного з'єднання).
\end{enumerate}

\subsection*{Суперглобальні масиви PHP}
\index{PHP!змінні!суперглобальні масиви}
\textbf{Суперглобальними масивами} (superglobal arrays) в PHP називаються зумовлені масиви, які видно в будь-якому місці вихідного коду без використання ключового слова \verb'global'.


Доступ до змінних оточення здійснюється через суперглобальний масив \verb'$_SERVER' у вигляді \verb|$_SERVER['змінна_CGI']|; Наприклад код
\begin{verbatim}
print $_SERVER['SERVER_SOFTWARE'];
\end{verbatim}
роздрукує в браузері строку виду:
\begin{verbatim}
Apache/2.2.4 (Win32) mod_ssl/2.2.4 OpenSSL/0.9.8k PHP/5.3.3
\end{verbatim}


Повний перелік змінних оточення web-сервера Apache та суперглабальних масивів PHP дивіться у додатках~\ref{var-apa:app} та~\ref{sup-glob:app}.


\pagebreak[3]



\section{Оператори PHP}
\nopagebreak[4]
\index{PHP!оператори}
Синтаксис PHP дуже нагадує синтаксис мови C і багато в чому запозичений з таких мов як Java і Perl. Інструкції поділяються також як і в C або Perl~--- кожен вираз закінчується крапкою з комою. Закриваючий тег <<?> >> також має на увазі кінець інструкції.

Коментарі застосовуються в PHP для запису власних зауважень під час процесу розробки коду. Такі коментарі можуть визначати призначення сегмента коду або їх можна використовувати для виключення блоків коду під час тестування і налагодження сценаріїв.

Синтаксичний аналізатор PHP ігнорує коментарі. Коментарі в PHP можна визначити одним з наступних способів:
\begin{enumerate}

\item \verb|//|~--- Простий коментар PHP;
\item \verb|#|~--- Альтернативний простий коментар PHP;
\item \verb|/* ... */|~--- Багаторядкові блоки коментарів.

\end{enumerate}
\penalty -10000
Імена змінних позначаються знаком \$.

\begin{verbatim}
<?php
$message = "Привет, я - скрипт PHP!";
echo $message;
?>
\end{verbatim}
\index{PHP!змінні!типи даних}
PHP підтримує вісім простих типів даних \label{datatypes}:
\begin{enumerate}
\item Чотири скалярних типи:
		\begin{itemize}
		\item Boolean (двійкові дані)
		\item Integer (цілі числа)
		\item Float (числа з плаваючою точкою або 'double')
		\item String (рядки)
		\end{itemize}
\item Два змішаних типи:
		\begin{itemize}
		\item Array (масиви)
		\item Object (об'єкти)
		\end{itemize}
\item Два спеціальних типи:
		\begin{itemize}
		\item resource (ресурси)
		\item NULL (<<порожні>>)
		\end{itemize}
\item Існують також кілька псевдотіпов:
		\begin{itemize}
		\item Mixed (змішані)
		\item Number (числа)
		\item Callback (зворотний визов)		
		\end{itemize}
\end{enumerate}

Основними конструкціями мови PHP є:
\index{PHP!конструкції}
\begin{enumerate}
\item Умовні оператори (\verb|if, else|);
\item Цикли (\verb|while, do-while, for, foreach, break, continue|);
\item Конструкції вибору (\verb|switch|);
\item Конструкції оголошення (\verb|declare|);
\item Конструкції повернення значень (\verb|return|);
\item Конструкції включень (\verb|require, include|).
\end{enumerate}


Для здійснення операцій зі змінними існують різні групи операторів. Оператором називається дещо, що складається з одного або більше значень (виразів), яке можна обчислити як нове значення (таким чином, вся конструкція може розглядатися як вираз).

\textbf{Оператори бувають трьох видів.}
\begin{enumerate}
\item Унарні оператори, які працюють тільки з одним аргументом, наприклад, <<!>> (оператор заперечення) або <<++>> (інкрімент).
\item Бінарні оператори: до них належать більшість підтримуваних в PHP операторів
\item тернарних оператор <<\dots?\dots:\dots>>. Він використовується для умовного вибору між двома операторами, в залежності від результату обчислення третього оператора.
\end{enumerate}
\subsection*{Пріоритет виконання операторів}
\index{PHP!оператори!пріоритети}
Пріоритет операторів визначає, в якому порядку будуть обчислюватися два і більше вирази. Наприклад, вираз $1 + 5 * 3$ обчислюється як 16, а не 18, оскільки операція множення <<*>> має більш високий пріоритет, ніж операція додавання <<+>>. У разі, якщо оператори мають однаковий пріоритет, вони будуть виконуватися зліва направо. Круглі дужки можуть використовуватися для примусового вказівки необхідного порядку виконання операторів. Наприклад, вираз $(1 + 5) * 3$ обчислюється як 18.

В таблиці~\ref{pr-op:table} додатку надано пріоритети виконання операторів PHP.

Ліва асоціативність вказує на те, що вираз обчислюється зліва направо, права асоціативність відповідно має увазі протилежний порядок.
\pagebreak[3]
\section{Конструкції вибору}
\index{PHP!конструкції!розгалуження}
\nopagebreak[4]
До конструкцій вибору відносять: умовний оператор (\verb'if...else') і перемикач (\verb'switch'). 
\subsection*{if \dots else}
Синтаксис умовного оператора:
\begin{verbatim}
if (condition) statement1 else statement2
\end{verbatim}


Умова \verb'condition' може бути будь-яким виразом. Якщо \verb'condition' істинне, то виконується оператор \verb'statement1' . В іншому випадку виконується оператор \verb'statement' 2. Допустима скорочена форма запису умовного оператора, в якій відсутні \verb'else' і оператор \verb'statement2'.

У свою чергу, оператори \verb'statement1' і \verb'statement2' можуть бути умовними, що дозволяє організовувати послідовність перевірок будь-якої глибини вкладеності. І в цих послідовностях кожен умовний оператор може бути як повним, так і скороченим. У зв'язку з цим можливі помилки неоднозначного зіставлення \verb'if' і \verb'else'.

Зауважимо, що перевірка додаткових умов можлива за допомогою оператора \verb|elseif|. Оператор \verb|if| може включати скільки завгодно блоків \verb'elseif', але else в кожному if може бути тільки один. Як правило, в конструкціях \verb'if ... elseif ... else' оператор else визначає, що потрібно робити, якщо ніякі інші умови не є true. 

РНР надає також можливість альтернативного синтаксису умовного оператора~--- без фігурних дужок, а із застосуванням оператора \verb'endif', при цьому оператори будуть розміщені всередині блока.

\subsection*{Перемикач <<switch>>}

Перемикач \verb'switch' є найбільш зручним засобом для організації множинного розгалуження. Синтаксис перемикача такий:
\penalty -10000
\begin{verbatim}
switch (expression) 
{
case value1: statements; break;
case value2: statements; break;
default:
statements;
}
\end{verbatim}

Керуюча структура \verb'switch' передає керування тому з помічених \verb'case' операторів, для якого значення константного виразу збігається зі значенням \verb'expression'. Якщо значення \verb'expression' не збігається ні з одним з константних виразів, то виконується перехід до оператора, поміченого міткою \verb'default'. У кожному перемикачі може бути не більше однієї мітки \verb'default', однак вона може бути відсутньою взагалі.


\pagebreak[3]

\section{Конструкції циклів}
\nopagebreak[4]

\index{PHP!конструкції!цикли}

На другому місці за частотою використання, після конструкцій умов (умовних операторів), знаходяться цикли.

Цикли дозволяють повторювати певну (і навіть невизначений~--- коли робота циклу залежить від умови) кількість разів різні послідовності операторів. Дані оператори називаються тілом циклу. Прохід циклу називається ітерацією.

PHP підтримує чотири види циклів:
\begin{itemize}
\item    Цикл з передумовою (while)
\item    Цикл з постусловіем (do-while)
\item    Цикл з лічильником (for)
\item    Спеціальний цикл перебору масивів (foreach)
\end{itemize}

Цикли зручно також використовувати при форматуванні HTML-сторінки. Наприклад при створенні великих списків або таблиць.

\begin{lstlisting}[caption=Формування HTML-сторінки за допомогою циклів]
<!DOCTYPE html PUBLIC "-//W3C//DTD/XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml11-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title> Страница Web </title>
</head>
<body>
<table>
<?php
for (int $i=1; $i<=10; $i++) 
echo "<tr><td> Рядок № </td><td>$i</td></tr>\n";
?>
</table>
</body>
</html>
\end{lstlisting}




Сценарій для тієї самої сторінки без використання циклів зайняв б у два рази більше дискового простору.

При використанні циклів є можливість використання операторів \verb'break' і \verb'continue'. Перший з них перериває роботу всього циклу, а другий~--- тільки поточної ітерації.


\subsection*{Цикл з передумовою while}
\index{PHP!конструкції!while}
Цикл з передумовою while працює за такими принципами:

\begin{enumerate}
\item    Обчислюється значення логічного виразу.
\item    Якщо значення істинно, виконується тіло циклу, в іншому випадку~--- переходимо на наступний за циклом оператор.
\end{enumerate}


Синтаксис циклу з передумовою:
\begin{verbatim}
while (логічний_вираз) інструкція;
\end{verbatim}

В даному випадку тілом циклу є інструкція. Зазвичай тіло циклу складається з великої кількості операторів. Наведемо приклад циклу з передумовою while:
\begin{verbatim}
<? Php
$х = 0;
while ($x++<10) echo $x;
// Виводить 12345678910
?>
\end{verbatim}
Зверніть увагу на послідовність виконання операцій умови \$x++<10. Спочатку перевіряється умова, а тільки потім збільшується значення змінної. Якщо ми поставимо операцію інкремента перед змінної (++\$x<10), то спочатку буде виконано збільшення змінної, а тільки потім~--- порівняння. У результаті ми отримаємо рядок <<123456789>>. 


Подібно конструкції умовного оператора \verb'if', можна групувати оператори всередині тіла циклу while, використовуючи наступний альтернативний синтаксис:
\begin{verbatim}
while (логічний_вираз):
інструкція;
...
endwhile;
\end{verbatim}

\subsection*{Цикл з постумовою do while}
\index{PHP!конструкції!do while}
На відміну від циклу \verb'while', цей цикл перевіряє значення виразу не до, а після кожного проходу (ітерації). Таким чином, тіло циклу виконується хоча б один раз. Синтаксис циклу з постумовою такий:
\begin{verbatim}
do
{
тело_цікла;
}
while (логічний_вираз);
\end{verbatim}
Після чергової ітерації перевіряється, чи істинний \verb'логічний_вираз', і, якщо це так, управління передається знову на початок циклу, в іншому випадку цикл обривається.

\subsection*{Цикл з лічильником <<for>> (регулярний цикл)}
\index{PHP!конструкції!for}
Цикл з лічильником використовується для виконання тіла циклу певне число разів. 

Синтаксис циклу \verb'for' такий:
\begin{verbatim}
for (ініціалізуючі_команди; умова_роботи; 
	команди_після_ітерації) {тіло_цикла;}
\end{verbatim}
Цикл for починає свою роботу з виконання \verb'ініціалізуючіх_команди'. Дані команди виконуються тільки один раз. Після цього перевіряється \verb'умова_роботи', якщо воно істинно (true), то виконується \verb'тіло_цикла'. Після того, як буде виконаний останній оператор тіла, виконуються \verb'команди_після_ітерації'.



Для циклу for є і альтернативний синтаксис:
\begin{verbatim}
for (ініціалізуючі_команди; умова_роботи; 
команди_після_ітерації):
оператори;
endfor;
\end{verbatim}

\subsection*{Цикл перебору масивів <<foreach>>}
\index{PHP!конструкції!foreach}
В PHP4 з'явився ще один спеціальний тип циклу~--- \verb'foreach'. Даний цикл призначений спеціально для перебору масивів.

Синтаксис циклу \verb'foreach' виглядає наступним чином:
\begin{verbatim}
foreach (масив as $ключ => $значення)
команди;
\end{verbatim}
Тут команди циклічно виконуються для кожного елемента масиву, при цьому чергова пара <<ключ => значення>> виявляється в змінних \verb'$ключ' і \verb'$значення'. 

У циклу foreach є й інша форма запису, яку слід застосовувати, коли нас не цікавить значення ключа чергового елемента. Виглядає вона так:
\begin{verbatim}
foreach (масив as $значення)
команди;
\end{verbatim}
У цьому випадку доступно лише значення чергового елементу масиву, але не його ключ. Це може бути корисно, наприклад, для роботи з масивами-списками:



Увага: Цикл \verb'foreach' оперує не вихідним масивом, а його копією. Це означає, що будь-які зміни, які вносяться в масив, не можуть бути <<видимі>> з тіла циклу. Що дозволяє, наприклад, в якості масиву використовувати не тільки змінну, але і результат роботи якої-небудь функції, що повертає масив (у цьому випадку функція буде викликана всього один раз~--- до початку циклу, а потім робота буде проводитися з копією повернутого значення).

\subsection*{Конструкція <<break>>}
\index{PHP!конструкції!break}
Дуже часто для того, щоб спростити логіку якого-небудь складного циклу, зручно мати можливість його перервати в ході чергової ітерації (наприклад, при виконанні якого-небудь особливого умови). Для цього і існує конструкція break, яка здійснює негайний вихід з циклу. Вона може задаватися з одним необов'язковим параметром~--- числом, яке вказує, з якого вкладеного циклу має бути здійснений вихід. За замовчуванням використовується 1, тобто вихід з поточного циклу, але іноді застосовуються й інші значення. Синтаксис конструкції \verb'break':
\begin{verbatim}
break; // За замовчуванням
break (номер_цикла); // Для вкладених циклів 
(вказується номер циклу, що переривається)
\end{verbatim}

\subsection*{Конструкція <<continue>>}
\index{PHP!конструкції!continue}
Конструкція \verb'continue' так само, як і \verb'break', працює тільки <<в парі>> з циклічними конструкціями. Вона негайно завершує поточну ітерацію циклу та переходить до нової (звичайно, якщо виконується умова циклу для циклу з передумовою). Точно так само, як і для \verb'break', для continue можна вказати рівень вкладеності циклу, який буде продовжений з повернення управління.


\pagebreak[3]

\section{Конструкції включення}
\nopagebreak[4]
Конструкції включень дозволяють збирати PHP програму (скрипт) з декількох окремих файлів.

У PHP існують дві основні конструкції включень: \verb'require' і \verb'include'.
\subsection*{Конструкція включень <<require>>}
\index{PHP!конструкції!require}
Конструкція \verb'require' дозволяє включати файли в сценарій PHP до виконання сценарію PHP. Загальний синтаксис \verb'require' такий:
\begin{verbatim}
require им'я_файлу;
або
require (им'я_файлу);
\end{verbatim}
При запуску (саме при запуску, а не при виконанні!) Програми інтерпретатор просто замінить інструкцію на вміст файлу \verb|им'я_файлу| (цей файл може також містити сценарій на PHP, обрамлений, як зазвичай, тегами << <? >> та << ?> >>'). Причому зробить він це безпосередньо перед запуском програми (на відміну від include , який розглядається нижче). Це буває досить зручно для включення в висновок сценарію різних шаблонних сторінок HTML-кодом. 
\subsection*{Конструкція <<include>>}
\index{PHP!конструкції!include}
Конструкція \verb'include' також призначена для включення файлів в код сценарію PHP.

На відміну від конструкції \verb'require' конструкція \verb'include' дозволяє включати файли в код PHP скрипта під час виконання сценарію. Синтаксис конструкції \verb'include' виглядає наступним чином:
\penalty -10000
\begin{verbatim}
include им'я_файлу;
або
include (им'я_файлу);
\end{verbatim}

Принципова різниця між цими двома операторами в тому, що \verb'include' дозволяє включати файли <<на літу>>, і робити це декілька разів, наприклад у циклах.
\subsection*{Конструкції одноразового включення <<require\_once>> і <<include\_once>>}
\index{PHP!конструкції!require\_once} \index{PHP!конструкції!include\_once}
У великих PHP сценаріях інструкції \verb'include' і \verb'require' застосовуються дуже часто. Тому стає досить складно контролювати, як би випадково не включити один і той же файл декілька разів, що найчастіше призводить до помилки, яку складно виявити.

У PHP передбачено вирішення даної проблеми. Використовуючи конструкції одноразового включення \verb'require_once' і \verb'include_once', можна бути впевненим, що один файл не буде включено двічі. Працюють конструкції одноразового включення \verb'require_once' і \verb'include_once' так само, як і \verb'require' і \verb'include' відповідно. Різниця в їх роботі лише в тому, що перед включенням файлу інтерпрететор перевіряє, чи включений вказаний файл раніше чи ні. Якщо так, то файл не буде включено знову. 

\subsection*{Включення віддалених файлів}

Конструкції однократних включень \verb'require_once' і \verb'include_ince' також дозволяють включати віддалені файли, якщо така можливість включена в конфігураційному файлі PHP.

Якщо \verb'URL fopen' увімкнено в PHP (як у конфігурації за замовчуванням), ви можете специфікувати файл, що підключається з використанням URL (через HTTP), замість локального шляху. 

Для того, щоб віддалене включення файлів було доступно, необхідно в конфігураційному файлі (php.ini) встановити \verb'allow_url_fopen = 1'.


\pagebreak[3]

\section{Конструкція <<or exit()>> (<<or die()>>)}
Конструкція складається з логічного оператора \verb'or' та функції \verb'exit()' або її псевдоніма \verb'die()'. Функція \verb'exit(статус)' друкує на екрані статус, котрий може бути цілочисельною або рядковою константою. Конструкцію зручно використовувати під час налагодження сценаріїв у комбінації з функціями, які можуть повертати логічне \verb'FALSE'. Наприклад зупинку сценарію при невдалому відкритті файлу можна отримати таким чином:
\begin{verbatim}
$file = fopen("file.txt","w+") or die("Помилка відкриття файлу");
\end{verbatim} 



\pagebreak[3]

\section{Індивідуальне завдання}

\nopagebreak[4]
\subsection*{Завдання до лабораторної роботи}
\nopagebreak[4]
\begin{enumerate}
\item Вивчити теоретичний матеріал
\item Відповісти на контрольні запитання
\item Скласти алгоритм (блок-схему) програми
\item Виконати практичне завдання
\item Скласти звіт
\item Захистити роботу
\end{enumerate}

\subsection*{Контрольні запитання}
\nopagebreak[4]
\begin{enumerate}
\item Які оператори виводу тексту ви знаєте?
\item Які групи змінних оточення ви знаєте?
\item Що таке суперглобальні масиви, як ними користуватись?
\item Яким чином можна задати коментар?
\item Які типи операторів ви знаєте?
\item Які конструкції вибору ви знаєте?
\item Які конструкції циклів ви знаєте?
\item У якому випадку цикл виконується хоча-б один раз?
\item Якими чином можна включити інший текстовий файл у сценарій?
\item Яка особливість операторів <<include\_once>> та <<require\_once>>? 
\end{enumerate}

\subsection*{Практичні завдання}
\nopagebreak[4]


\begin{enumerate}
 
\item[]Створити окремий РНР-файл, підключити його у головну сторінку. Файл повинен:
\item У регулярному циклі виводити числа від 1 до 20
\item У циклі з передумовою виводити числа від 20 до 50
\item У циклі з постумовою вивести числа від -50 до -10
\item Використовуючи регулярний цикл вивести елементи арифметичної прогресії з 20 елементів починаючи з 1 та доданком 2
\item Використовуючи з передумовою вивести елементи геометричної прогресії з 20 елементів починаючи з 1 та доданком 2
\item Розрахувати факторіал 10 за допомогою регулярного циклу
\item Вивести латинський алфавіт, використовуючи регулярний цикл
\item Вивести латинський алфавіт, використовуючи цикл з передумовою
\item Вивести Цифри від 20 до 0 у зворотньому порядку, використовуючи цикл з постумовою.
\item[]Написати HTML-сторінку з формою, що складається з однорядкового поля вводу та кнопки відправлення форми. В поле вводу ввести число та обчислити вираз: 
\item якщо $x>0$ то $5*x^2 + 2*x - 10$, інакше $5*x^2 + 2*x + 10$
\item якщо $0<x\le 10$ то $10*x^3 - 2*x - 10$, інакше $x^2 + 20*x$
\item якщо $0<x\le 20$ то $\frac{x}{x+1} + 2*x - 10$, інакше $\frac{x+1}{x} + 10$
\item якщо $-10<x\le 0$ то $5*x^2 + 2*x - 10$, $x> 0$ $5*x^2 + 2*x + 10$, інакше $\frac{x+1}{x} + 10$
\item якщо $x\le 10$ то $x^3 + 2*x^2$, інакше $2*x + 10$
\item якщо $x>10$ то $5*x^2 + \frac{x}{2}$, інакше $\frac{x+10}{x+1}$
\item[]Написати HTML-сторінку з формою, що складається з однорядкового поля вводу та кнопки відправлення форми. В поле вводу ввести число та використовуючи конструкцію <<switch-case>>: 
\item за номером дня тижня вивести його назву.
\item за номером місяця року вивести його назву.
\item від 0 до 10 вивести назви цифр
\item відповідно номера вивести букву латинського алфавіту
\item[]Опрацювати змінні оточення 
\item вивести шлях до каталогу з веб-документами
\item вивести підпис веб-сервера
\item вивести інформацію про браузер користувача
\item вивести адресу електронної пошти адміністратора
\item за допомогою конструкції перебору масивів вивести зміст \$\_SERVER
\item за допомогою конструкції перебору масивів вивести зміст \$\_ENV

\end{enumerate}
