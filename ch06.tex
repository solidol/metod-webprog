\chapter{Сесії у РНР. Відправлення e-mail}
\section*{Мета роботи}
Навчитися використовувати сесії РНР та cookies. Розібратися в механізмі роботи сесій та cookies. Навчитися використовувати вбудовані засоби відправлення e-mail.
\section{Авторизація доступу}
У сучасних, навіть не дуже складних, веб-системах виникає потреба ідентифікувати користувача та виділити йому окреме поле діяльності. Якщо інформацію про ім'я, пароль та права користувача можна зберігати у файлах або у таблиці бази даних, то залишається проблема стеження за наявністю користувача на сайті.

Цю проблему можна вирішити двома способами:
\begin{itemize}
\item встановленням \verb'cookies'
\item запуском сесії.
\end{itemize}

Механізм сесій налаштований таким чином, що використовує механізм \verb'cookies' для передачі даних, але можливо обходитись і без \verb'cookies' у разі, коли вони відключені у користувача.
\section{Механізм сесії. Налаштування сесії}
\index{PHP!сесії}
\textbf{Сесія}~--- це механізм, який дозволяє створювати і використовувати змінні, зберігають своє значення протягом всього часу роботи користувача з сайтом.

Ці змінні для кожного користувача мають різні значення і можуть використовуватися на будь-якій сторінці сайту до виходу користувача з системи. При цьому кожного разу, заходячи на сайт, користувач отримує нові значення змінних, що дозволяють ідентифікувати його протягом цього сеансу або сесії роботи з сайтом. Звідси й назва механізму~--- сесії. 

Ідентифікатор сесії є 128 бітним числом. Якщо людина прийшла на сайт вперше і PHP-процесор це бачить, то даним відвідувачу присвоюється число, не присвоєне ще нікому. Надалі, при повторному заході, відвідувач буде асоційований з його особистим числом (ідентифікатором), через що програмі буде надана персональна область пам'яті.

Подання ідентифікатору сесії здійснюється у вигляді рядку із 32-х байт. Приклади ідентифікаторів сесії:

\begin{itemize}
\item \verb'7f4cbf53fbcd4717792447f32da7dba8'
\item \verb'ac4f4a45bdc893434c95dcaffb1c1811'
\end{itemize}

Налаштування PHP, в тому числі і для роботи з сесіями, прописуються у файлі \verb'php.ini'. В додатку~\ref{ses-opt:table} та~\ref{ses-opt-full:table} дано базові налаштування механізму сесії.

\subsection*{Унікальність сесій}
Підробити сесію або ідентифікатор не можна. Число з 128 біт (це 2 в 128 ступеня) в десятковому поданні має 38 нулів. Припустимо, на Вашому сайті буде 10~000 відвідувачів. Тоді у хакера шанси кілька зростають до 2 в ступені 114. Але це так само нереальна ймовірність~--- що-небудь підробити. Одна з очевидних причин наступна. Щоб підібрати номер сесії, потрібно зробити запит до Вашого веб-сервера. Нехай кожен запит займає 1024 байти. Через мільярд звернень до Вашого сайту, що складе 1000 ГБ трафіку, явно щось трапиться: Ваш сайт відключать через дикого трафіку або у вас не вистачить грошей на оплату такого великого трафіку. Ваш канал або пропускна здатність провайдера занадто слабка, щоб в розумні терміни перебрати всі номери. Ваш сервер не зможе хоч якось швидко працювати, маючи гігантську кількість пустих файлів, через створення фіктивних сесій. Ваш сервер переповниться лог-файлами і файлами фіктивних сесій, перестане працювати.

\subsection*{Збереження даних сесій}
Є два популярних способи зберігання даних сесій: база даних і файли. Ще можна зберігати сесії в пам'яті сервера (ОЗУ), але при виключенні сервера усі дані будуть втрачені. Зазвичай сесії зберігають у файлах, щоб знизити навантаження на базу даних. У деяких випадках сесії дозволяють повністю відмовитися від бази даних або використовувати її мінімально: в базі даних тільки список логінів/паролів, в сесіях (на файлах) вся робоча інформація.

За замовчуванням PHP зберігає всі в файлах (у своєму форматі) і сам дістає з них збережені дані. Після роботи кожного сценарію PHP сам все записує назад в особистий файл.

\subsection*{Передача ідентифікатора сесії}
Для передачі ідентифікатора сесії існують два основних способи і кілька маловживаних. Розглянемо скорочено механізм їх роботи:

\begin{enumerate}
\item \textbf{Cookies}

Це самий популярний і ефективний спосіб передачі ідентифікатора. Можна один раз помістити в куку змінну і всі інші скрипти будуть її отримувати. Якщо у користувача куки включені, PHP сам помістить туди ідентифікатор і потім сам його звідти дістане. 

Якщо у користувача куки вимкнені, то робота з сайтом може стати неможливою.

\item \textbf{параметри}
\begin{verse}
http://php.spb.ru/test.php?PHPSESSID=ac4f4a45bdc893434c95dcaffb1c1811
\end{verse}

Якщо ви будете дописувати всі ваші посилання подібним чином, то всі ваші наступні скрипти отримають ідентифікатор. PHP використовує і даний метод за замовчуванням (поєднуючи з куками, якщо ті вимкнені). Тобто PHP сам застосує або куки, або отриманий параметр.

Використання такого способу э 100\% надійним, але являється украй небезпечним, т.я. будь-хто може підробити параметр і отримати конфіденціальні дані користувача.

\item \textbf{PathInfo}
\begin{verse}
http://php.spb.ru/test.php/ac4f4a45bdc893434c95dcaffb1c1811
\end{verse}

Це засновано на розумінні веб-сервером того, де з цього URL шлях до скрипта, а де параметри. Тобто Апач розпізнає даний виклик, як звернення до файлу test.php і передасть йому рядок у змінній \verb'$pathinfo = getenv ("PATH_INFO")'. Відповідно, щоб передати управління в інший скрипт, треба подібним чином скласти URL (GET-запит) або передати форму GET або POST запитом.

\item Існують ще методи передачі ідентифікатора сесії, але вони ще менш зручні та не можуть надати надійного захисту від підробки.

\end{enumerate}



\section{Створення сесії, реєстрація змінних сесії, видалення змінних сесії}
\index{PHP!сесії!змінні сесії}
\index{PHP!функції!сесії}
При роботі із сесією виділяють три наступні етапи:
\begin{enumerate}
\item відкриття сесії
\item реєстрація змінних та їх використання
\item закриття сесії
\end{enumerate}
Нижче буде розглянуто всі три етапи.

\subsection*{Створення сесії}
Перше, що потрібно зробити для роботи з сесіями (якщо вони вже налаштовані адміністратором сервера), це запустити механізм сесій. Якщо в налаштуваннях сервера змінна \verb'session.auto_start = 0' (якщо \verb'session.auto_start = 1', то сесії запускаються автоматично), то будь-який скрипт, в якому потрібно використовувати дані сесії, повинен починатися з команди
\begin{verbatim}
  session_start(); 
\end{verbatim}

Отримавши таку команду, сервер створює нову сесію або відновлює поточну, ґрунтуючись на ідентифікаторі сесії, переданому за запитом.  Інтерпретатор PHP шукає змінну, в якій зберігається ідентифікатор сесії (за замовчуванням це \verb'PHPSESSID') спочатку в \verb'cookies', потім у змінних, переданих за допомогою \verb'POST' і \verb'GET'-запитів. Якщо ідентифікатор знайдений, то користувач вважається ідентифікованим, проводиться заміна всіх URL і виставляння \verb'cookies'. В іншому випадку користувач вважається новим, для нього генерується новий унікальний ідентифікатор, потім проводиться заміна URL і виставляння \verb'cookies'.

Нижче дано приклад роботи сесії:

\begin{verbatim}
<?
session_start(); 
echo session_id(); 
?>
<html>
<head><title>My home page</title></head>
... // домашняя страничка
</html>
<?
echo session_name(); 
?>
\end{verbatim}

Якщо оновити таку сторінку, то буде видно, що рядок, котрий друкує \verb'echo session_id();', не змінюється. Це вказує на те, що оновлення сесії проводиться успішно. Якщо закрити вікно браузера та відкрити цю сторінку знову, \verb'echo session_id();' видасть нове значення, томущо \verb'cookies' з минулої сесії вже знищено.


\subsection*{Реєстрація змінних}
Однак від самих ідентифікатора та імені сесії нам користі для вирішення завдань небагато. На практиці необхідно передавати щонайменше логін та пароль користувача. Для того щоб цього досягти, потрібно просто зареєструвати свої змінні:
\begin{verbatim}
session_register (ім'я_змінної1, 
        ім'я_змінної2, ...); 
\end{verbatim}
Зауважимо, що реєструються не значення, а імена змінних. Зареєструвати змінну досить один раз на будь-якій сторінці, де використовуються сесії. Імена змінних передаються функції \verb'session_register()' без знака <<\$>>. Всі зареєстровані таким чином змінні стають глобальними протягом даної сесії роботи з сайтом. 



\subsection*{Видалення змінних, сесії}
Крім вміння реєструвати змінні сесії (тобто робити їх глобальними протягом усього сеансу роботи), корисно також вміти видаляти такі змінні і сесію в цілому.

Функція \verb|session_unregister(ім'я_змінної)| видаляє глобальну змінну з поточної сесії (тобто видаляє її зі списку зареєстрованих змінних). Якщо реєстрація проводилася за допомогою \verb'$_SESSION', то використовують мовну конструкцію \verb'unset()'. Вона не повертає ніякого значення, а просто знищує зазначені змінні. Для того щоб скинути значення всіх змінних сесії, можна використовувати функцію \verb'session_unset();'.

Знищити поточну сесію цілком можна командою \verb'session_destroy();'. Вона не скидає значення глобальних змінних сесії і не видаляє \verb'cookies', а знищує всі дані, асоційовані з поточною сесією.

Перелік згаданих вище функцій дано у додатку~\ref{ses-func:text}. 
\section{Робота з cookies}
\index{PHP!cookies}

\textbf{Cookies}~--- це механізм зберігання даних браузером віддаленого комп'ютера для ідентифікації відвідувачів, що повертаються, та зберігання параметрів веб-сторінок (наприклад, змінних).

\textbf{Cookies}~--- це текстові рядки, що зберігаються на стороні клієнта, і містять пари <<ім'я-значення>>, з якими пов'язаний URL, по якому браузер визначає чи потрібно посилати \verb'cookies' на сервер.

Етапи роботи з  \verb'cookies' схожі на етапи використання механізму сесій:
\begin{enumerate}
\item встановлення \verb'cookies'
\item використання \verb'cookies'
\item видалення \verb'cookies'
\end{enumerate}
\subsection*{Встановлення cookies}
Встановлення cookies проводиться за допомогою функції \verb'setcookie()'. Ця функція має такі аргументи:
\begin{itemize}
\item \verb'name'~--- ім'я встановлюваного cookie;
\item \verb'value'~--- значення, яке зберігається в \verb'cookie' з ім'ям name;
\item \verb'expire'~--- час в секундах з початку епохи, по витікання якого поточний \verb'cookie' стає недійсним;
\item \verb'path'~--- шлях, по якому доступний cookie;
\item \verb'domain'~--- домен, з якого доступний cookie;
\item \verb'secure'~--- директива, яка визначає, чи доступний \verb'cookie' не по запиту HTPPS. За замовчуванням ця директива має значення 0, що означає можливість доступу до \verb'cookie' по звичайному запитом HTTP. 
\end{itemize}

При використанні Cookies необхідно мати на увазі, що Cookies повинні встановлюватися до першого виводу інформації в браузер (наприклад, оперетором echo або висновком якої функції). Тому бажано встановлювати Cookies на самому початку скрипта. Cookies встановлюються за допомогою певного заголовка сервера, а якщо скрипт виводить небудь, то це означає, що починається тіло документа. В результаті Cookies не будуть встановлені і може бути виведено попередження. Для перевірки успішності установки Cookies можна використовувати такий метод:

\begin{verbatim}
<?php
if (SetCookie("Test","Value")) 
echo "<h3>Cookies успішно встановлено!</h3>";
?>
\end{verbatim}

Функція \verb'SetCookie()' повертає TRUE у разі успішного встановлення Cookie. У разі, якщо Cookie встановити не вдається \verb'SetCookie()' поверне FALSE і можливо, попередження (залежить від налаштувань PHP). 


\subsection*{Використання cookies}

Доступ до \verb'cookie' здійснюється через суперглобальний масив \verb'$_COOKIE["name"]', де <<name>>~--- ім'я параметру, значення котрого необхідно отримати.

При читанні значень Cookies звертайте увагу на перевірку існування Cookies, наприклад, використовуючи оператор \verb'isset()'. Або шляхом придушення виведення помилок опереатором <<@>>.

Приклад встановлення Cookie і подальшого його читання:
\begin{verbatim}
<? php
setcookie( "test" , "Hello" , time()+3600 );
echo @$_COOKIE['test'];
?>
\end{verbatim}

У прикладі нижче показано як створити лічильник завантажень сторінки:
\begin{lstlisting}[caption=Лічильник завантажень сторінки]
<?php
// Проверяем, был ли уже установлен Cookie 'Mortal',
// Если да, то читаем его значение,
// И увеличиваем значение счетчика обращений к странице:
if (isset($_COOKIE['Mortal'])) $cnt=$_COOKIE['Mortal']+1;
else $cnt=0;
// Устанавливаем Cookie 'Mortal' зо значением счетчика,
// С временем "жизни" до 18/07/29,
// То есть на очень долгое время:
setcookie("Mortal",$cnt,0x6FFFFFFF);
// Выводит число посещений (загрузок) этой страницы:
echo "<p>Вы посещали эту страницу <b>".@$_COOKIE['Mortal']."</b> раз</p>";
?>
\end{lstlisting}

\subsection*{Встановлення масиву cookies}

Ми може встановити масив Cookies, використовуючи квадратні дужки в іменах Cookies \verb'[]', а потім прочитати масив Cookies і значення цього масиву:

\begin{lstlisting}[caption=Масив Cookies]
 <? php
// Устанавливаем массив Cookies:
setcookie("cookie[1]","Первый");
setcookie("cookie[2]","Второй");
setcookie("cookie[3]","Третий");
// После перезагрузки страницы мы отобразим
// Состав массива Cookies 'cookie':
if (isset($_COOKIE['cookie']))   
{
foreach ($_COOKIE ['cookie'] as $name => $value )   
   {
   echo "$name : $value <br>";
   }
}
?> 
\end{lstlisting}

\subsection*{Видалення cookies}

Іноді виникає необхідність видалення Cookies. Зробити це нескладно, необхідно лише знову встановити Cookie з ідентичним ім'ям і порожнім параметром. Наприклад:
\begin{verbatim}
<? php
SetCookie("Test" , "" );
?> 
\end{verbatim}


\section{Відправлення e-mail}
\index{PHP!функції!mail()}
\index{PHP!e-mail}
Найпростіший спосіб відправити лист за допомогою PHP~--- скористатися стандартною функцією \verb'mail()'. Вона має наступний синтаксис:
\begin{verbatim}
bool mail(to, subject, message [, additional\_headers 
[, additional\_parameters]])
\end{verbatim}

Обов'язкові параметри:
\begin{itemize}
\item E-mail одержувача
\item Заголовок листа
\item Текст листа 
\end{itemize}

Необов'язкові параметри:
\begin{itemize}
\item Додаткові заголовки листи
\item Додаткові параметри командного рядка 
\end{itemize}
Повертає значення:
\begin{itemize}
\item true, якщо лист було прийнято до доставки
\item false, в іншому випадку. 
\end{itemize}
Найпростіший приклад її використання виглядає так:
\begin{verbatim}
<?php
mail("joecool@example.com" , "My Subject" , "Line 1\nLine 2\nLine 3" );
?>
\end{verbatim}
Якщо у Вас на екрані з'явилася помилка <<Fatal error: Call to undefined function: mail()>>, це означає, що або PHP зібраний без підтримки функції mail, або вона заборонена налаштуваннями сервера. Така практика останнім часом широко поширена на безкоштовних хостингових серверах. Якщо Ви зіткнулися з такою проблемою, скористайтеся можливістю відправки листів за допомогою сокетів (sockets). 


\section{Альтернатива <<mail()>>}
\index{Системні додатки!sendmail}
На сьогоднішній день поширені наступні способи відправки листів з php-скриптів:
\begin{enumerate}
\item За допомогою виклику функції mail
\item Безпосередньо викликом sendmail
\item За допомогою сокетів
\item Використовуючи COM-об'єкт 
\end{enumerate}
\subsection*{sendmail}
\begin{lstlisting}[caption=Використання sendmail]
<?php
$sendmail = "/usr/sbin/sendmail -t -f $sender -C /etc/sendmail.orig.cf";
$fd = popen($sendmail, "w");
fputs($fd, "To: recipient@example.com\r\n");
fputs($fd, "From: \"Sender Name\" <$sender>\r\n");
fputs($fd, "Subject: Finally\r\n");
fputs($fd, "X-Mailer: Mailer Name\r\n\r\n");
fputs($fd, $body);
pclose($fd);
?> 
\end{lstlisting}
\subsection*{Active-X (COM)}
\begin{lstlisting}[caption=Використання Active-X]
<?php
@$CDONTS = new COM("CDONTS.NewMail");

@$CDONTS->From = "from_user@domain.com";
@$CDONTS->To = "to_user@domain.com";
@$CDONTS->CC = "cc_user@domain.com";
@$CDONTS->BCC = "bcc_user@domain.com";

@$CDONTS->BodyFormat = 0;
@$CDONTS->MailFormat = 0;

//@$CDONTS->AttachFile("c:\file.txt");

@$CDONTS->Subject = "Using CDONTS with PHP4 and IIS";
@$CDONTS->Body = "Blah blah blah blah, bleh...";

@$CDONTS->Send();
@$CDONTS->Close();
?> 
\end{lstlisting}

У разі роботи з сокетом відправлення дещо ускладнюється. Роботу з сокетами буде розглянуто в наступних лабораторних роботах.

\pagebreak[3]
\section{Індивідуальне завдання}

\nopagebreak[4]
\subsection*{Завдання до лабораторної роботи}
\nopagebreak[4]
\begin{enumerate}
\item Вивчити теоретичний матеріал
\item Відповісти на контрольні запитання
\item Скласти алгоритм (блок-схему) програми
\item Виконати практичне завдання
\item Скласти звіт
\item Захистити роботу
\end{enumerate}

\subsection*{Контрольні запитання}
\nopagebreak[4]
\begin{enumerate}
\item Що таке сесії? Для чого вони потрібні?
\item Яким чином забезпечується унікальність сесій?
\item Де зберігаються дані сесії?
\item Як створити сесію? 
\item Яким чином додати та видалити змінну сесії?
\item Що таке cookies?
\item Як використовувати cookies?
\item Як створити та використати масив cookies?
\item Яким чином можна відправити електронний лист?
\item Які альтернативи відправлень електронних листів ви знаєте?
\end{enumerate}

\subsection*{Практичні завдання}
\nopagebreak[4]


\begin{enumerate}
\item[]Написати HTML-сторінку з полями вводу логіну та паролю та додати наступний функціонал:
\item створити гостьову книгу, що зберігає запис користувача, виводить його записи, та дозволяє додавати нові без повторної авторизації
\item створити гостьову книгу що виводить перелік повідомлень та дозволяє видаляти їх певному користувачу без повторної авторизації
\item створити книгу рецептів, що дозволяє додавати, та дивитись додані рецепти тільки власнику записів послідовно без повторної авторизації
\item створити книгу рецептів, що дозволяє одному користувачу додавати рецепти, а іншому~--- видаляти
\item створити фотогалерею, що дозволяє додавати зображення та виводити їх перелік без повторної авторизації
\item створити фотогалерею, що дозволяє додавати зображення та видаляти їх певному користувачу без повторної авторизації
\item створити декілька зв'язаних сторінок, для різних користувачів виводити різну інформацію
\item створити примітивний форум на кілька користувачів (авторизація, додавання повідомлення, виведення повідомлень та імен користувачів)
\item створити сайт зі статтями, дати можливість просмотру неавторизованим користувачам та додавання авторизованим
\item створити сайт за статтями, дати можливість певним користувачам видаляти їх, заборонити просмотр неавторизованим користувачам
\item створити примітивний форум на кілька користувачів (авторизація, додавання повідомлення, виведення повідомлень та імен користувачів), що працює виключно на cookies
\item створити гостьову книгу, що зберігає запис користувача, виводить його записи, та дозволяє додавати нові без повторної авторизації, книга працює виключно на cookies
\item створити книгу рецептів, що дозволяє одному користувачу додавати рецепти, а іншому~--- видаляти, книга працює виключно на cookies
\item створити фотогалерею, що дозволяє додавати зображення та виводити їх перелік без повторної авторизації, фотогалерею працює виключно на cookies
\item створити примітивний онлайн-щоденник (додавання записів, виведення списку записів)
\item створити примітивний онлайн-щоденник (додавання записів, виведення списку записів), авторизацію користувача проводити за допомогою cookies
\item створити простий калькулятор (<<+>>, <<->>, <<*>>, <</>>) та виводити історію користувацьких обчислень 
\item створити простий калькулятор (<<+>>, <<->>, <<*>>, <</>>) та виводити історію користувацьких обчислень, авторизацію користувача проводити за допомогою cookies
\item створити гостьову книгу що виводить перелік повідомлень та дозволяє видаляти їх певному користувачу без повторної авторизації, авторизацію користувача проводити за допомогою cookies
\item створити простий калькулятор (<<+>>, <<->>, <<*>>, <</>>), записувати історію обчислень та виводити її адміністратору сайту
\item створити сторінку, що виводить адміністратору логін та пароль користувачів, та дозволяє їх змінювати 
\item створити сторінку, що виводить адміністратору логін та привілеї користувача, та дає право надавати права адміністратора
\item створити сторінку, яка дозволяє адміністратору видаляти користувачів з системи
\item створити сторінку, яка дозволяє додавати користувачів в систему
\item  створити фотогалерею, що дозволяє додавати зображення та видаляти їх певному користувачу без повторної авторизації, авторизацію користувача проводити за допомогою cookies
\item[]Результати роботи виводити у браузері.

\end{enumerate}


